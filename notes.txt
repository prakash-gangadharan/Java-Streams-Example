
Java 17 - features
Spring security
load  balancing 
Design Pattern in the Microservice Architecture

Interceptors in spring:
1. Logging and Monitoring:
2. Authentication and Authorization
3. Request Validation:
4. Request/Response Transformation
5. Performance Tracking: 

HandlerInterceptor

preHandle(): Called before the request reaches the controller.
postHandle(): Called after the controller processes the request but before the response is sent.
afterCompletion(): Called after the request is fully processed

----------------------------------------------------

Bean life cycle in spring:

@primary  & @qualifier

Prototype & Builder pattern

@Transactional - Attributes



Prototype - Creational Pattern

Why default methods were introduced in the Interface?

- Provide external functionality without breaking the existing implementations
- To provide backward compatibility to the Collection Framework with the new lambda functions

-----------------------------------------------------------

1. Database per service pattern
2. Backend for Frontend (BFF) Pattern
3. Saga pattern
4. API gateway pattern
5. Aggregator design pattern
6. Circuit breaker design pattern
7. Command query responsibility segregation (CQRS)
8. Asynchronous messaging
9. Event sourcing - kafka
10. Decomposition patterns





select salary from employee order by salary desc LIMIT 1 Offset 2


-----------------------------------------------------------



public class Test1 {
public static void main(String[] args) {
	Emp e1 = new Emp("1","Name");
	Emp e2 = new Emp("1","Name");
	Set<Emp> ss = new HashSet<Emp>();
	ss.add(e2);
	ss.add(e1);
	System.out.println(ss.size()); -> 2
}
}
class Emp{
	String id;
	String name;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Emp(String id, String name) {
		super();
		this.id = id;
		this.name = name;
	}
	
}



-------------------------------------------------------------------------------------


Map<String,Integer> mapFruit = new HashMap<>();
mapFruit.put("Apple", 30);
mapFruit.put("Grape", 10);
mapFruit.put("PineApple", 40);

sort based on the number of fruits





